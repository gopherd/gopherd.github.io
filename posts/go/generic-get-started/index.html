<!doctype html><html lang><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<title>Go 泛型初步</title><meta name=description content="mkideal's Blog">
<meta name=author content="mkideal">
<link rel=stylesheet href=/css/fonts.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/font-awesome/css/all.min.css>
<link rel=stylesheet href=/sass/researcher.min.css>
<link rel="short icon" type=image/ico href="https://gopherd.com/favicon.ico?v=1.0">
<link rel=icon type=image/ico href="https://gopherd.com/favicon.ico?v=1.0">
<script data-ad-client=ca-pub-4848513853142926 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-77412491-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-77412491-1")</script>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/prism.css>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/components/prism-core.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script src=/js/lib/jquery-3.6.0.min.js></script>
<script src=/js/lib/bootstrap.bundle.min.js></script>
<script src=/js/mongo.js data-forward-url=https://code.gopherd.com/forward data-app-id=data-egkqp data-source=Cluster0 data-database=blog_mkideal_com data-collection></script>
<script src=/js/codeblock.js data-forward-url=https://code.gopherd.com/forward></script>
<script src=/js/runner/go.js data-forward-url=https://code.gopherd.com/forward></script>
<script src=/js/runner/rust.js data-forward-url=https://code.gopherd.com/forward></script>
<script src=/js/runner/lua.js data-forward-url=https://code.gopherd.com/forward></script>
<script src=/js/runner/sololearn.js data-forward-url=https://code.gopherd.com/forward></script>
<script src=/js/runner/onecompiler.js data-forward-url=https://code.gopherd.com/forward></script>
<script>codeblock.init({shareCodeURL:"https://gopherd.com/tools/playground"});var oldHighlightAll=Prism.highlightAll;Prism.highlightAll=function(e,t){document.querySelectorAll('code:not([data-lang=""])').forEach(function(e){var t=e.getAttribute("data-lang"),n;t&&(n=codeblock.syntaxName(t),t!==n&&(e.className&&e.className.includes("language-"+t)&&(e.className=e.className.replace("language-"+t,"")),(!e.className||!e.className.includes("language-"+n))&&(console.log("add syntax class",n),e.className=(e.className||"")+" language-"+n)))}),oldHighlightAll(e,t)},$(function(){$('[data-toggle="tooltip"]').tooltip({trigger:"hover",delay:{show:250,hide:250}}),navigator&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)&&$(document).on("shown.bs.tooltip",function(e){setTimeout(function(){$(e.target).tooltip("hide")},2e3)})})</script>
</head><body>
<div class="container mt-5" style=margin-top:1rem!important>
<nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
<a class="navbar-brand mx-0 mr-sm-auto" href=https://gopherd.com/ title>
<img src=https://gopherd.com/img/logo.svg width=187 height=34 alt=logo>
</a>
<div class="navbar-nav flex-row flex-wrap justify-content-center">
<a class="nav-item nav-link" href=/ title=主页>
主页
</a>
<span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/tools title=工具>
工具
</a>
</div></nav></div><hr>
<div id=content>
<div class=container>
<article>
<header>
<p><i class="fa-regular fa-calendar"></i> <span class=app-item-time>2022年2月12日</span>
</p><h1 class="center-text article-title" style=margin-bottom:10px>Go 泛型初步</h1></header><div>
<h4 class=text-center style=margin-top:32px;margin-bottom:10px><strong>摘&nbsp;&nbsp;要</strong></h4><span>Go 1.18 版本之后正式引入泛型，它被称作类型参数（type parameters），本文初步介绍 Go 中泛型的使用。</span>
</div><div style=margin-top:10px>
<strong>关键词: </strong>
<code class=keyword>go</code>
<code class=keyword>泛型</code>
<code class=keyword>类型参数</code>
</div><aside data-toc-type=float-right>
<span>目录</span>
<nav id=TableOfContents>
<ul>
<li><a href=#1-go-的泛型>1. Go 的泛型</a></li><li><a href=#2-安装-go-118-以上的版本>2. 安装 go 1.18 以上的版本</a></li><li><a href=#3-函数类型参数>3. 函数类型参数</a>
<ul>
<li><a href=#31-泛型版本的求和函数>3.1. 泛型版本的求和函数</a></li><li><a href=#32-使用泛型实现一个类似脚本语言比如-javascript的或运算>3.2. 使用泛型实现一个类似脚本语言（比如 javascript）的或运算</a></li><li><a href=#33-使用泛型实现三元条件运算>3.3. 使用泛型实现三元条件运算</a></li></ul></li><li><a href=#4-类型泛型>4. 类型泛型</a>
<ul>
<li><a href=#41-类型泛型的基本使用方法>4.1. 类型泛型的基本使用方法</a></li><li><a href=#42-实现一个通用的事件系统>4.2. 实现一个通用的事件系统</a></li></ul></li><li><a href=#5-结语>5. 结语</a></li></ul></nav></aside><h2 id=1-go-的泛型>1. Go 的泛型</h2><p>长期以来 go 都没有泛型的概念，只有接口 <code>interface</code> 偶尔类似的充当泛型的作用，然而接口终究无法满足一些基本的泛型需求，比如</p><p>(1). 函数体内需要对参数做运算而不是使用接口方法，如下的写法连编译都不可行。</p><div class=highlight code=+b><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Sum 函数尝试对输入的任意多个参数求和。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 然而 interface{} 不可以做加法，这段代码是不能编译的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>values</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sum</span> <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>values</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(2). 使用接口常常存在极其令人厌恶的接口转换，一个例子是标准库 <code>container/heap</code>。<code>Pop</code> 方法返回值几乎总是需要在逻辑上再转换为 <code>Push</code> 时传入的类型，这使得代码不仅丑陋而且低效（曾经因为 interface{} 实际是 int 类型，但是因为类型转换导致大量的内存分配次数）</p><div class=highlight code=-><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Push pushes the element x onto the heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The complexity is O(log n) where n = h.Len().
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>Interface</span>, <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pop removes and returns the minimum element (according to Less) from the heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The complexity is O(log n) where n = h.Len().
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Pop is equivalent to Remove(h, 0).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Pop</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>Interface</span>) <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>因为没有泛型而带来的其他问题就不一一列举，相信许多开发者都有遇到需要泛型的场景。从 go 1.18 版本开始，将正式引入泛型，官方称谓叫做类型参数 <code>type parameter</code>，由于各种原因，现阶段的泛型比起一些流行语言中的泛型功能上还是差很多，不过总比没有好了。目前泛型主要使用的方式有两类：<code>函数</code>的类型参数，<code>类型</code>的类型参数。</p><h2 id=2-安装-go-118-以上的版本>2. 安装 go 1.18 以上的版本</h2><p>在 go1.18 尚未正式发布时可以通过如下命令安装 beta 版本体验</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go install golang.org/dl/go1.18beta2@latest
</span></span><span style=display:flex><span>go1.18beta2 download
</span></span></code></pre></div><p>此后可以使用 <code>go1.18beta2</code> 命令取代原来的 go 命令编译支持泛型的代码。</p><h2 id=3-函数类型参数>3. 函数类型参数</h2><h3 id=31-泛型版本的求和函数>3.1. 泛型版本的求和函数</h3><p>仍以求和函数为例，泛型版本的写法如下：</p><div class=highlight code=sum><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;golang.org/x/exp/constraints&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sum</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Integer</span>](<span style=color:#a6e22e>values</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sum</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>values</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote>
<p>constraints 原本是放在标准库的包，但是近期被移除了，改到了 x/exp 中，参见 <a href=https://github.com/golang/go/issues/50792 target=_blank>#50792</a></p></blockquote><p>这个版本实现了对任意多个同类型的整数求和。<code>Sum</code> 后面的中括号 <code>[]</code> 内就是定义类型参数的地方，其中 <code>T</code> 为类型参数名，<code>constraints.Integer</code> 是对该类型参数的约束，即 T 应该满足的条件，在这里我们要求 <code>T</code> 是一个整数。剩下的代码就和普通没有泛型的代码一致了，只不过后面 T 可以当作一个类型来使用。标准库 <code>constraints</code> 中预定义了一些基本的约束，另外还有两个特殊的内置类型可用作约束：<code>any</code> 和 <code>comparable</code>，其中 <code>any</code> 就是原来的 <code>interface{}</code>，在 go1.18 开始所有空 interface{} 都改成 any 了，而 <code>comparable</code> 则表示类型是可以通过 <code>==</code> 运算符进行比较的。</p><blockquote>
<p>go 的泛型参数为什么不使用其他流行语言的 <code>&lt; ></code> 定义泛型？这个主要是会引起语法上的歧义，比如下面这一段代码</p><p>x, y := a &lt; b, c > d</p></blockquote><p>现在可以来使用一下刚才定义的 <code>Sum</code> 方法：</p><div class=highlight code=sum+x><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Sum</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ints</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>ints</span><span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>int32s</span> = []<span style=color:#66d9ef>int32</span>{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>int32s</span><span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>uint32s</span> = []<span style=color:#66d9ef>uint32</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>uint32s</span><span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 调用 Sum 函数时也可以将类型参数带上，只是经常都能够通过实际参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 类型推断类型参数，所以常常省略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Sum</span>[<span style=color:#66d9ef>uint32</span>](<span style=color:#a6e22e>uint32s</span><span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个版本仍有一些问题，比如可以做加法的不止整数啊，还有浮点数，甚至是复数。修改类型参数 <code>T</code> 的约束来支持浮点数和复数：</p><div class=highlight code=sum2+x><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;golang.org/x/exp/constraints&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sum</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Integer</span> | <span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Float</span> | <span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Complex</span>](<span style=color:#a6e22e>values</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sum</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>values</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Sum</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>3.5</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过符号 <code>|</code> 连接多个约束表示 <code>T</code> 只需满足其中任意一个。</p><p><code>Sum</code> 函数的例子只用了一个类型参数，go 的类型参数也支持多个，这个定义和函数参数的格式类似。</p><div class=highlight code=-><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>FuncA</span>[<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>U</span> <span style=color:#a6e22e>any</span>]() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>FuncB</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>U</span>, <span style=color:#a6e22e>V</span> <span style=color:#a6e22e>comparable</span>]() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>接下来通过几个简单的例子熟练一下泛型函数的使用。</p><h3 id=32-使用泛型实现一个类似脚本语言比如-javascript的或运算>3.2. 使用泛型实现一个类似脚本语言（比如 javascript）的或运算</h3><p>这个例子用于判定 <code>a</code> 是否为 zero 值，如果是则返回 <code>b</code>，反之返回 <code>a</code>。</p><div class=highlight code=$+x><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Or</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>](<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>zero</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>zero</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>z</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>x</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>y</span>, <span style=color:#e6db74>&#34;default&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>z</span>, <span style=color:#a6e22e>createString</span>()))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createString</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>doSomething</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>doSomething</span>(<span style=color:#ae81ff>12</span>, <span style=color:#e6db74>&#34;y&#34;</span>, <span style=color:#e6db74>&#34;z&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过不同于一般的或运算，这里 <code>Or(a, b)</code> 时 b 的值已经确定，如果 b 是一个函数调用，那么当 a 不是 zero 值时，b 的函数调用完全浪费了。</p><blockquote>
<p>javascript 中的 <code>a || b()</code> 不同于此处的 <code>Or(a, b())</code>，前者在 a 非空时不会调用函数 b</p></blockquote><p>可以再实现一个延迟函数调用的版本 <code>OrNew</code> 处理这种情况：</p><div class=highlight code=$+x><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Or</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>](<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>zero</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>zero</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>OrNew</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>](<span style=color:#a6e22e>a</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>func</span>()<span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>zero</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>zero</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> new()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>z</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>x</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>y</span>, <span style=color:#e6db74>&#34;default&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>OrNew</span>(<span style=color:#a6e22e>z</span>, <span style=color:#a6e22e>createString</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createString</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>doSomething</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>doSomething</span>(<span style=color:#ae81ff>12</span>, <span style=color:#e6db74>&#34;y&#34;</span>, <span style=color:#e6db74>&#34;z&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=33-使用泛型实现三元条件运算>3.3. 使用泛型实现三元条件运算</h3><p>go 语言不存在三元条件运算符 <code>&lt;condition>? value1 : value2</code>，导致经常存在需要这种场景时只好用 <code>if</code> 写好几行的代码，不过现在可以通过泛型实现一个条件运算了。</p><div class=highlight code=$+x><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>If</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>yes</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>yes</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>IfNew</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>yes</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>yes</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createA</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;a&#34;</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createB</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;b&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>If</span>(<span style=color:#a6e22e>a</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>IfNew</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>createA</span>, <span style=color:#a6e22e>createB</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=4-类型泛型>4. 类型泛型</h2><h3 id=41-类型泛型的基本使用方法>4.1. 类型泛型的基本使用方法</h3><p>以一个 c++ 的 <code>std::pair</code> 为例，来说明 go 的类型泛型的使用。<code>pair</code> 包含 first 和 second 两个成员，并且每一个都有独立的类型，所以我们需要两个类型参数，先看代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span> <span style=color:#a6e22e>any</span>] <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>First</span>  <span style=color:#a6e22e>T1</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Second</span> <span style=color:#a6e22e>T2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MakePair</span>[<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>first</span> <span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>second</span> <span style=color:#a6e22e>T2</span>) <span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span>] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span>]{<span style=color:#a6e22e>First</span>: <span style=color:#a6e22e>first</span>, <span style=color:#a6e22e>Second</span>: <span style=color:#a6e22e>second</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pair</span> <span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span>]) <span style=color:#a6e22e>Elements</span>() (<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>First</span>, <span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>Second</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在定义 Pair 时在类型名称之后使用 <code>[T1, T2 any]</code> 定义了类型参数，即 T1, T2 都可以是任意类型。</p><p>然后定义了泛型函数 <code>MakePair</code> 用于创建 Pair 对象，函数的返回值类型为 <code>Pair[T1, T2]</code>。</p><p>最后实现了 Pair 的成员方法 <code>Elements</code> 返回两个成员值，这个函数看起来很无聊，似乎没什么用，就是用来展示如何定义泛型类型的成员方法。和一般的类型的成员方法的定义的区别在于类型 Pair 之后必须要使用声明 Pair 类型时定义的类型参数（就是这里的 <code>[T1, T2]</code>）。</p><p>另外 go 的泛型目前不支持给成员方法声明新的类型参数，比如这种成员方法的定义就不允许：</p><div class=highlight code=+b><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Bad: 成员方法后面不能声明类型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pair</span> <span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T1</span>, <span style=color:#a6e22e>T2</span>]) <span style=color:#a6e22e>Something</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>]() {}
</span></span></code></pre></div><p>除了 <code>struct</code> 之外，interface 的定义也支持类型参数（但是它的接口方法不支持类型参数），但是 <code>type alias</code> 不支持类型参数</p><div class=highlight code=-><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>] <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 自己定义的接口 User 可用作类型参数的约束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InterfaceTwo</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>U</span> <span style=color:#a6e22e>User</span>] <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntPair</span> <span style=color:#a6e22e>Pair</span>[<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Slice</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>] []<span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Bad: 这个不允许
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Vector</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>] = []<span style=color:#a6e22e>T</span>
</span></span></code></pre></div><p>类型约束除了内置的 <code>any</code>, <code>comparable</code> 以及 <code>golang.org/x/exp/constraints</code> 中定义的之外，也可以使用自己定义的任意接口用作约束，就像上例中的 <code>User</code>。另外现在除了以前概念中的 interface 定义之外，还有一种纯粹只能用于类型参数约束的 interface。像这类使用了基础类型或者 <code>|</code> 运算的接口。</p><div class=highlight code=-><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 实数约束 Real 只能用于类型参数约束，而不能作为普通参数或变量类型。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Real</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Integer</span> | <span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Float</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Number 包含一个只能用于约束的接口，所以也只能用于类型参数的约束了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Number</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Real</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Cat</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Float</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#66d9ef>float32</span> | <span style=color:#960050;background-color:#1e0010>~</span><span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>String</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PureString</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Name 满足 String 约束，但是不满足 PureString
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span></code></pre></div><p>go 1.18 开始引入一个新的符号 <code>~</code> 用于约束前缀，这表示该约束包含 underlying 为该类型的参数。比如上面的 <code>Name</code> 类型的 underlying 是 string，所以 <code>Name</code> 也满足 <code>String</code> 约束，但是不满足 <code>PureString</code> 约束。</p><h3 id=42-实现一个通用的事件系统>4.2. 实现一个通用的事件系统</h3><p>有了类型泛型可以实现一个比较实用的功能：事件派发系统。</p><p>首先我们需要定义一个事件接口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Event 是一个事件接口，类型参数 T 表示事件类别的数据类型，比如可以使用
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	string
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	int
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	reflect.Type
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	...
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 该接口定义 Type 方法获取事件类别
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>] <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Type</span>() <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后定一个事件处理接口 <code>Listener</code>，同时为了使用方便实现一个内置的 listener</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Listener 接口用于处理被触发的事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Listener</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>] <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>EventType</span>() <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Handle</span>(<span style=color:#a6e22e>Event</span>[<span style=color:#a6e22e>T</span>])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Listen 创建一个 Listener 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Listen</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>, <span style=color:#a6e22e>E</span> <span style=color:#a6e22e>Event</span>[<span style=color:#a6e22e>T</span>]](<span style=color:#a6e22e>eventType</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>handler</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>E</span>)) <span style=color:#a6e22e>Listener</span>[<span style=color:#a6e22e>T</span>] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>listenerFunc</span>[<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>E</span>]{<span style=color:#a6e22e>eventType</span>, <span style=color:#a6e22e>handler</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>listenerFunc</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>, <span style=color:#a6e22e>E</span> <span style=color:#a6e22e>Event</span>[<span style=color:#a6e22e>T</span>]] <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>eventType</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>handler</span>   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>E</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>listenerFunc</span>[<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>E</span>]) <span style=color:#a6e22e>EventType</span>() <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>eventType</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>listenerFunc</span>[<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>E</span>]) <span style=color:#a6e22e>Handle</span>(<span style=color:#a6e22e>event</span> <span style=color:#a6e22e>Event</span>[<span style=color:#a6e22e>T</span>]) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>event</span>.(<span style=color:#a6e22e>E</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>handler</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;unexpected event %T for type %v&#34;</span>, <span style=color:#a6e22e>event</span>, <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>Type</span>()))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面这段代码需要特别说明一下 <code>Listen</code> 函数，该函数有 2 个类型参数 <code>T</code> 和 <code>E</code>，前者是事件类别的类型参数，后者是事件类型参数，而 <code>E</code> 的约束 <code>Event[T]</code> 中依赖了前一个泛型参数，这样一来事件处理函数 <code>handler</code> 的参数就不再是 <code>Event</code> 接口而是一个泛型参数了，这避免了每次在回调函数中进行一次类型转换（因为已经统一在 listenerFunc.Handle 中转换了）。比如以前经常是这样写回调函数</p><div class=highlight code=-><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>onSomething</span>(<span style=color:#a6e22e>event</span> <span style=color:#a6e22e>Event</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>somethingEvent</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>event</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>SomethingEvent</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unexpected event type&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// doSomething with somethingEvent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>而现在回调函数就可以避免每次手动转换类型了</p><div class=highlight code=-><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>onSomething</span>(<span style=color:#a6e22e>event</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>SomethingEvent</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// doSomething with event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>接下来实现事件派发管理器 <code>Dispatcher</code>。<code>Dispatcher</code> 需要实现事件注册(Add)，删除(Remove)，检查(Has)和派发(Dispatch) 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Dispatcher 管理事件注册与派发
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Dispatcher</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>comparable</span>] <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nextid</span>    <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>listeners</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>T</span>][]<span style=color:#a6e22e>Pair</span>[<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>Listener</span>[<span style=color:#a6e22e>T</span>]]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mapping</span>   <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T</span>, <span style=color:#66d9ef>int</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// AddEventListener 注册事件回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dispatcher</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dispatcher</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>AddEventListener</span>(<span style=color:#a6e22e>listener</span> <span style=color:#a6e22e>Listener</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>T</span>][]<span style=color:#a6e22e>Pair</span>[<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>Listener</span>[<span style=color:#a6e22e>T</span>]])
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#a6e22e>Pair</span>[<span style=color:#a6e22e>T</span>, <span style=color:#66d9ef>int</span>])
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>nextid</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>id</span> = <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>nextid</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>eventType</span> = <span style=color:#a6e22e>listener</span>.<span style=color:#a6e22e>EventType</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>listeners</span> = <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>eventType</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>index</span> = len(<span style=color:#a6e22e>listeners</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>eventType</span>] = append(<span style=color:#a6e22e>listeners</span>, <span style=color:#a6e22e>MakePair</span>(<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>listener</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span>[<span style=color:#a6e22e>id</span>] = <span style=color:#a6e22e>MakePair</span>(<span style=color:#a6e22e>eventType</span>, <span style=color:#a6e22e>index</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// HasEventListener 判定是否存在事件回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dispatcher</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dispatcher</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>HasEventListener</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span>[<span style=color:#a6e22e>id</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ok</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// RemoveEventListener 删除事件回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dispatcher</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dispatcher</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>RemoveEventListener</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>index</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span>[<span style=color:#a6e22e>id</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>eventType</span> = <span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>First</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>listeners</span> = <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>eventType</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>last</span> = len(<span style=color:#a6e22e>listeners</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>Second</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>last</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>Second</span>] = <span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>last</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>newId</span> = <span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>Second</span>].<span style=color:#a6e22e>First</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span>[<span style=color:#a6e22e>newId</span>] = <span style=color:#a6e22e>MakePair</span>(<span style=color:#a6e22e>eventType</span>, <span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>last</span>].<span style=color:#a6e22e>Second</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>eventType</span>] = <span style=color:#a6e22e>listeners</span>[:<span style=color:#a6e22e>last</span>]
</span></span><span style=display:flex><span>	delete(<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>mapping</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DispatchEvent 派发事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dispatcher</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dispatcher</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>DispatchEvent</span>(<span style=color:#a6e22e>event</span> <span style=color:#a6e22e>Event</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>listeners</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>Type</span>()]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>listeners</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>listeners</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>listeners</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Second</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#a6e22e>event</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，一个基本的事件系统就完成了，接下来看看如何使用。</p><div class=highlight code=+x><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 这个例子中事件的 Type 使用 string 类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>testEventA</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>testEventB</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>testEventA</span>) <span style=color:#a6e22e>Type</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;A&#34;</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>testEventB</span>) <span style=color:#a6e22e>Type</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;B&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dispatcher</span> <span style=color:#a6e22e>Dispatcher</span>[<span style=color:#66d9ef>string</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 注册事件，listener 通过 Listen 方法构建
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>AddEventListener</span>(<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>testEventA</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;test event &#39;A&#39; fired&#34;</span>)
</span></span><span style=display:flex><span>	}))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>AddEventListener</span>(<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;B&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testEventB</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;test event &#39;B&#39; fired&#34;</span>)
</span></span><span style=display:flex><span>	}))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 派发事件，注意由于通过 Listen 注册的时候回调函数的参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 没有使用指针，所以这里派发事件时也不能用 testEvent 的指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 这两者的类型必须要一致
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>DispatchEvent</span>(<span style=color:#a6e22e>testEventA</span>{})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 事件 B 的类型就需要指针了，因为注册时使用了指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dispatcher</span>.<span style=color:#a6e22e>DispatchEvent</span>(new(<span style=color:#a6e22e>testEventB</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除了这个例子中的使用 string 作为事件类别的类型外，还可以使用整数，reflect.Type 或其他任意可比较的类型。</p><p>事件系统的完整代码可参见 <a href=https://github.com/gopherd/doge/blob/main/event/event.go target=_blank>github.com/gopherd/doge/blob/main/event/event.go</a></p><h2 id=5-结语>5. 结语</h2><p>总体来说，go 的泛型功能还是较少的，使用限制较多。另外 go 1.18 版本的泛型存在一个严重的性能问题：范型参数存在不必要的内存逃逸，而且执行速度低下，在 go 1.19 的 Milestone 中已经有提交来修正这个问题了（<a href=https://github.com/golang/go/issues/50182 target=_blank>#50182</a>）。然而内存逃逸的问题修复了，性能却仍然比非范型的版本差。</p><p>目前建议只在满足以下条件之一的时候使用范型：</p><ul>
<li>普通基础类型用作类型参数约束</li><li>参数类型约束没有成员方被调用</li><li>对性能没有极致要求</li></ul><br>
</article></div><hr>
<script src=https://utteranc.es/client.js repo=gopherd/gopherd.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div><div id=footer class=mb-5>
<br>
<hr>
<div class="container text-center">
<a href=https://github.com/mkideal class="fab fa-github fa-1x" title=GitHub></a>
<a href=https://twitter.com/mkideal class="fab fa-twitter fa-1x" title=Twitter></a>
<a href=https://facebook.com/mkideal.io class="fab fa-facebook fa-1x" title=Facebook></a>
<a href=mailto:i@mkideal.com class="fas fa-envelope fa-1x" title=E-mail></a>
</div></div></body></html>